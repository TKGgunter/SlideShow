    let mut temp_cursor = None;
    let mut temp_font_size = None;
    let mut temp_font_color = None;
    let mut temp_font_braced_line = None;
    //let mut temp_align = None;
    //let mut temp_font = None;
    let mut temp_default_cursor_x = 0.0;
    let mut next_text_row = 0;
    let mut text_row = 0;
    let mut prev_text_row = 0;
    let mut vec_delta_horizontal_cursor = 0;
    //for iter in slide_card.slide_data.iter(){
    let mut _iter = slide_card.slide_data.iter().peekable();
    loop{
        let __iter = _iter.next();
        if __iter == None{ break; }
        let iter = __iter.unwrap();


        match iter.config{
            Some(ref config_card) => {
                for iter_config in config_card.config_data.iter(){

                    match iter_config.kwd{
                        ConfigKwds::text_position=>{
                            let mut _cursor = [0.0f32;2];
                            match_value_arrf32data(&mut _cursor, &iter_config.data);
                            if _cursor[0] < 1.0 && _cursor[1] < 1.0 {
                                _cursor[0] *= slide_width;
                                temp_default_cursor_x = _cursor[0];
                                _cursor[1] *= slide_height;
                            }
                            temp_cursor = Some(_cursor);
                        },
                        ConfigKwds::font_size=>{
                            let mut _font_size = match_value_f32data(&font_size, &iter_config.data);
                            if _font_size <= 1.0{
                                _font_size *= slide_height;
                            }

                            temp_font_size = Some(_font_size);
                        },
                        ConfigKwds::font_color=>{
                            let mut _font_color = font_color.clone();
                            match_value_arrf32data(&mut _font_color, &iter_config.data);
                            for i in 0.._font_color.len(){
                                if _font_color[i] > 1.0{
                                    _font_color[i] = _font_color[i] / 255.0;
                                }
                            }
                            temp_font_color = Some(_font_color);
                        },
                        ConfigKwds::font_braced=>{
                            temp_font_braced_line = Some( match_value_f32data(&0.0, &iter_config.data));
                        }
                        _=>{
                            println!("What ever you want we don't do!");
                        }
                    }

                }

            },
            _=>{}
            
        }

        match iter.kwd{
            ConfigKwds::text=>{

                let temp_string = match_value_strdata("", &iter.data);
                if temp_string == "".to_string(){
                }
                else{
                    prev_text_row = text_row;
                    text_row = iter.text_row;
                    next_text_row = match _iter.peek(){ Some(_next_iter)=> _next_iter.text_row, None=>text_row*1};
                    unsafe{
                        //TODO: This is temparary we only want fonts from ttf files
                        let font = HpdfFont(HPDF_GetFont (pdf.0, CString::new("Helvetica").unwrap().as_ptr(), ptr::null_mut()));

                        //TODO:
                        //I don't like the way this looks be we have to handle temporary changes in
                        //font size.
                        let mut _font_size = font_size.clone();
                        if temp_font_size != None{ _font_size = temp_font_size.unwrap() }


                        let mut delta = 0.0;
                        if text_align == Alignment::Center{
                            delta = 0.5; 
                        }
                        else if text_align == Alignment::Right{
                            delta = 1.0; 
                        }


                        //TODO: 
                        //I can't believe this works with font example...
                        //Why does this work
                        if (text_row - prev_text_row) > 1 {
                            cursor[0] = cloned_document_settings.slide_text_pos[0] * slide_width;
                            cursor[0] = cursor[0] - delta*vec_delta_horizontal[vec_delta_horizontal_cursor];//- delta;
                            println!("{} {} {} ", temp_string, delta, cursor[0]);
                            
                        //TODO: Use correct next line thing
                            cursor[1] -= font_size; 
                        }
                            vec_delta_horizontal_cursor += 1;

                        if temp_cursor.is_some() {
                            if text_align == Alignment::Center{
                                delta = 0.5; 
                                unsafe{
                                    HPDF_Page_SetFontAndSize (page.0, font.0, _font_size*1.0);
                                    delta *= HPDF_Page_TextWidth( page.0,  cstring!(temp_string.as_str()).as_ptr() );
                                }
                            }
                            else if text_align == Alignment::Right{
                                delta = 1.0; 
                                unsafe{
                                    HPDF_Page_SetFontAndSize (page.0, font.0, _font_size*1.0);
                                    delta = HPDF_Page_TextWidth( page.0,  cstring!(temp_string.as_str()).as_ptr() );
                                }
                            }

                            temp_cursor = Some( [temp_default_cursor_x - delta, temp_cursor.unwrap()[1] - _font_size * temp_font_braced_line.unwrap()] ); //TODO: Use correct next line thing
                        }
                       


                        //TODO:
                        //Make all options swappable like this!
                        let mut _cursor = cursor.clone();
                        if temp_cursor != None{ _cursor = temp_cursor.unwrap() }

                        let mut _font_color = font_color.clone();
                        if temp_font_color != None{ _font_color = temp_font_color.unwrap() }

    //TODO:
    //let mut temp_align = None;
    //let mut temp_font = None;

                        _cursor = page.render_text( &temp_string, &_font_size, &font, &_font_color, &_cursor);
                        if temp_cursor.is_some(){
                            temp_cursor = Some(_cursor);
                        }
                        else{
                            cursor = _cursor;
                        }

                temp_cursor = None;
                temp_font_size = None;
                temp_font_color = None;


                    }
                }
            },
            _=>{
                println!("Not implemented {:?}", iter.data);
            }
        }
    }


